# 计算机网络
**ISO七层模型:** 物理层  数据链路层 网络层 传输层  会话层  表示层 应用用  
**ISO五层模型:** 物理层  数据链路层 网络层 传输层  应用层   
**为什么要分层？**
1. 易于实现和标准化各层独立，就可以把大问题分割成多个小问题，利于实现；
2. 灵活性好：如果某一层发生变化，只要接口不变，不会影响其他层；
3. 分层后，用户只关心用到的应用层，其他层用户可以复用；
4. 各层之间相互独立：高层不需要知道底层的功能是采取硬件来实现的，只需要知道通过底层的接口来获得所需要的服务。  

<br/>

### 应用层HTTP/HTTPS
##### 1. http和https区别？
1. https协议需要到ca申请证书，一般需要付费。
2. http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
3. http和https使用的是完全不同的连接方式，用的端口也不一样，前者是默认是80，后者默认是443。 
4. http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

##### 2. HTTPS请求过程
1. TCP三次握手，建立TCP连接;
2. 发送HTTP请求，提供客户端可使用的SSL和STL加密版本;
3. 服务端确认加密版本，同时返回证书(证书中有公钥);
4. 客户端确认证书的合法性;
5. 客户端公钥加密客户端根据随机数生产的私钥,并通过公钥加密，发送给服务端; 
6. 服务器用证书私钥解密数据传输的密钥，获得对称加密的密钥；
7. 服务器加密一段测试数据，发送给客户端; 
8. 客户端进行解析，校验通过后，进行HTTP通讯  

![https通讯原理](https://github.com/shaoxuefeng/interview/blob/master/2020-04/相关图片/https通讯过程.png "https通讯原理")  

##### 3. http1.0&http1.1&http2.0对比
**http1.0:** 无状态， 无连接  
问题: 无法复用连接、对头阻塞    
**http1.1:**   
&emsp;&emsp; **长连接:** Connection字段设置为Keep-Alive，可以保持HTTP连接不断开。    
&emsp;&emsp; **管道化(pipelining):** 客户端可以发送多个请求到服务端，但是服务器必须按照客户的请求顺序进行响应。(不是并行)   
&emsp;&emsp;  **缓存处理:** 协商缓存&强缓存(见下)  
&emsp;&emsp;  **Host字段:** 一个服务器能够用来创建多个Web站点  
&emsp;&emsp;  **断点续传**   
参考:[https://segmentfault.com/a/1190000020801458?utm_source=tag-newest](https://segmentfault.com/a/1190000020801458?utm_source=tag-newest)  
**http2.0:**  
&emsp;&emsp;  **二进制分帧:** 最小传输单位为帧; 流代表了一个完整的`请求-响应`数据交互过程。 采用二进制格式传输数据; 一个连接可以承载任意数量的双向数据流。  
&emsp;&emsp;  **多路复用:**   client 端就可以在一个链接中并发地发起多个请求，每个请求及该请求的响应不需要等待其他的请求。  
&emsp;&emsp;  **服务器推送:** 服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。  
&emsp;&emsp;  **首部压缩:** 支持DEFLATE和HPACK 算法的压缩，减少http头大小。  
参考: [https://zhuanlan.zhihu.com/p/26559480](https://zhuanlan.zhihu.com/p/26559480)  
**QUIC协议:**   
基于udp的多路复用流传输协议，是实现在udp上的 TCP+TLS+HTTP/2。

##### 4. http缓存(强缓存&协商缓存)
**强缓存:** 命中强缓存时，浏览器并不会将请求发送给服务器。http的返回码是200，但是在Size列会显示为(from cache)。    
**协商缓存:** 若未命中强缓存，则浏览器会将请求发送至服务器。服务器根据http头信息中的Last-Modify/If-Modify-Since或Etag/If-None-Match来判断是否命中协商缓存。如果命中，则http返回码为304，浏览器从缓存中加载资源。  
参考:[https://www.cnblogs.com/ranyonsue/p/8918908.html](https://www.cnblogs.com/ranyonsue/p/8918908.html)  

##### 5. session和cookie的区别(解决http的无状态性)
&emsp;&emsp; **存储位置不同：** cookie的数据信息存放在客户端浏览器上，session的数据信息存放在服务器上。    
&emsp;&emsp; **存储方式不同：** cookie中只能保管ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据；
session中能够存储任何类型的数据，包括且不限于string，integer，list，map等。  
&emsp;&emsp; **隐私策略不同：** cookie位于客户端，可以进行修改和篡改；session存储在服务器上，对客户端是透明对，不存在敏感信息泄漏的风险。  

##### 6. 在浏览器地址栏输入URL按回车键经历了什么？
1. 解析URL，检测地址是否合法
2. 浏览器先查看浏览器缓存；从系统缓存到 路由器缓存，如果缓存中有，会直接在屏幕中显示页面的内容：  
    * 浏览器缓存：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求
    * 操作系统缓存：如果在浏览器缓存中不包含这个记录，则会调用操作系统，获取操作系统的的记录（保存最近的DNS查询缓存）
    * 路由器缓存：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存
    * TSP缓存：若上述均失败，继续想ISP搜索
3. 发送http请求前需要域名解析（DNS解析）获取相应的IP地址
4. 浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手
5. 握手成功后，浏览器向服务器发送http请求，请求数据包
6. 服务器处理收到的请求，将数据返回至浏览器
7. 浏览器收到http响应
8. 浏览器解码响应，如果响应可以缓存，则存入缓存
9. 浏览器发送请求获取嵌入在HTML中的资源
10. 浏览器发送异步请求
11. 页面全部渲染结束

##### 7. http请求方式
get, post 和 head、options, put, delete, trace 和 connet 方法  
get、delete、put具有幂等性；  
post不具有幂等性，为了解决这个问题，提交post后，应该跳到新的页面，防止重复提交。  

<br/>

**GET和POST对比:**   
* GET产生一个TCP数据包；POST产生两个TCP数据包。  
* 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）。
* 对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 （返回数据）。

#### 8. restful
**restful的特点:**  
1. 轻量，直接基于http，不再需要任何别的诸如消息协议。get/post/put/delete对应CRUD操作； 
2. 具有自解释性，面向资源，一目了然。 
3. 无状态，在调用一个接口（访问、操作资源）的时候，可以不用考虑上下文，不用考虑当前状态，极大的降低了复杂度。  
4. 简单、低耦合; 
5. 标准话，通用化。  

**restful API规范:**     
**1. URI:** 表示资源，资源一般对应服务器端领域模型中的实体类。   
&emsp;&emsp;  **URI规范:**
* 不用大写;
* 用中杠-而不用下杠_;
* 参数列表要encode;
* URI中的名词表示资源集合，使用复数形式;

**2. Request:** HTTP方法 通过标准HTTP方法对资源CRUD。  
**3. Response:**  
&emsp;&emsp;  1). response 的 body 直接就是数据，不要做多余的包装。  
&emsp;&emsp;  2). json格式的约定： 时间用长整形(毫秒数)，客户端自己按需解析（moment.js） 不传null字段。   
&emsp;&emsp;  3). 分页response     
**4. 错误处理:**     
&emsp;&emsp;  1).  不要发生了错误但给2xx响应，客户端可能会缓存成功的http请求；  
&emsp;&emsp;  2).  正确设置http状态码，不要自定义；  
&emsp;&emsp;  3).Response body 提供 **错误的代码(日志/问题追查)** 和 **错误的描述文本（展示给用户）**。   
**5. 服务型资源:**  把这些服务看成资源，计算的结果是资源的presentation，按服务属性选择合适的HTTP方法。   
**6. 异步任务:**  对耗时的异步任务，服务器端接受客户端传递的参数后，应返回创建成功的任务资源，其中包含了任务的执行状态。客户端可以轮训该任务获得最新的执行进度。  
参考:[https://www.cnblogs.com/amou/p/9625368.html](https://www.cnblogs.com/amou/p/9625368.html)

<br/>

### 传输层 TCP/UDP
**使用场景:**  
TCP -- HTTP/HTTPS、FTP，SMTP等协议  
UDP -- 般用于即时通信、在线视频、网络语音电话、 QUIC协议, 包括DNS查询   
TCP 包的大小就应该是 1500 - IP头(20) - TCP头(20) = 1460 (Bytes)  
UDP 包的大小就应该是 1500 - IP头(20) - UDP头(8) = 1472(Bytes)  

<br/>

#### TCP知识点
#### 三次握手  
1. 户端发SYN包，同时包含一个客户端随机生成的初始seq， 进入SYN_SENT状态;  
2. 服务器处于Listen状态，接受服务当SYN包后，回SYN+ACK包，同时服务器端生成一个随机seq，进入SYN_RCVD状态；  

3.1 客户端接受SYN-ACK包，确认连接建立，进入ESTABLISHED状态;   
3.2 客户端发送ACK包，服务器收到ACK包后，也进入ESTABLISHED状态。   
![TCP三次握手](https://github.com/shaoxuefeng/interview/blob/master/2020-04/相关图片/TCP三次握手.png "TCP三次握手")   

**为什么需要三次握手？**  
1. 因为TCP是可靠、双向的传输，
2. 因此客户端和服务端都需要一个序列号，同时必须保证对方收到序列号。
3. 因此双方必须都给对方发送SYN，且接受到ACK。
4. 其中，服务端到客户端的SYN + ACK，可以合并到一次报文传输，（比四次握手效率更高）。

**为什么三次握手最后一次握手中， 在上面的示意图中回复的 seq = x+1 而不是 x+2？**   
TCP三次握手报文seq：   

        SYN=1，seq=x
        SYN=1，ACK=1，seq=y，ack=x+1
        ACK=1，seq=x+1，ack=y+1

TCP协议规定: 
> SYN报文，不能携带数据，但是需要消耗一个序列号  
> SYN+ACK报文，也不能携带数据，但是也需要消耗一个序列号  
> ACK报文可携带数据，如果不携带数据，则不消耗序列号    


**TCP半连接状态**  
TCP三次握手时，客户端进入了Established状态，但是服务端没有进去ESTABLISHED状态（一般在SYN-SEND状态）   
     &emsp;&emsp; **原因:**   
&emsp;&emsp;  Linux为全连接和半连接分别建立了一个列表，当全连接列表满时，处理半连接状态的TCP连接，即便完成了握手的后两次，仍无法进入ESTABLISHED状态（但是客户端进入了ESTABLISHED状态）。此时，服务端会重发SYN+ACK包，4次重传后，会丢弃当前的SYN-SEND状态。如果客户端发送来消息，服务端会回RST。

#### 四次挥手
1. 客户端发送FIN包，进入FIN-WAIT1状态，此时，已经停止客户端到服务端发送数据，但是客户端可以接受服务端的数据；  

2.1 服务端接受到FIN包，从ESTABLISHED状态，进入到CLOSE-WAIT状态，同时想客户端发送ACK包，确认已收到断开连接的请求;   
2.2 客户端接受到服务发送的ACK包，既然FIN-WAIT2状态(半关闭状态);  前两次挥手，让服务器知道了客户端想断开连接，客户端也确认服务器已知道自己想断开连接。  

3. 服务端在数据传输完后，向客户端发送FIN报文，进入LAST-ACK状态，客户端端接受FIN后，进入TIME-WAIT状态   

4.1 客户端接受FIN后，进入TIME-WAIT状态，同时恢复ACK包给服务端，确认自己收到FIN。  
4.2 服务端在接受到ACK后，确认可以关闭，进入CLOSED状态，客户端在等待2MSL后，也进组CLOSED状态。  

![TCP四次挥手](https://github.com/shaoxuefeng/interview/blob/master/2020-04/相关图片/TCP四次挥手.png "TCP四次挥手")  

##### 半断开状态  
TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。这就是所谓的半关闭。   
**CLOSE-WAIT过多:**  
&emsp;&emsp;  **代码层**: FIN包发送出现了问题，Fin包的底层实现其实就是调用socket的close方法。服务端socket忙于读写，比如：调用ServerSocket类的accept()方法和Socket输入流的read()方法时会引起线程阻塞。    
&emsp;&emsp;  **代码层**:可以设置TCP的连接时长keep_alive_time还有tcp监控连接的频率以及连接没有活动多长时间被迫断开连接。   
参考: [https://blog.csdn.net/qq_40910541/article/details/88677656](https://blog.csdn.net/qq_40910541/article/details/88677656) 

**TIME-WAIT状态:**   
**存在的必要性:**  
1. 为了防止最后一个ACK没有送到服务端。
    > 如果客户端立即关闭的话，服务端会重新发fin包，这时客户端关闭，服务端会收到RST，也就是一个报错。 

2. 为了防止当前连接中的重复报文干扰下一个连接。

**过多的解决办法:**  
1. 将短链接改成长连接，避免大量TCP短连接每次建立/释放产生的各种开销。
2. 修改内核参数： tcp_tw_recycle(time_wait快回收)、tcp_tw_reuse(time_wait可重用)、tcp_max_tw_buckets(缓冲作用)。

#### TCP中的各种机制  
1. ACK机制
2. 超时重传 -- linux中，以500ms为初始重传时间，当仍收不到时，重传时间会指数增长，累计到一定次数，可以强制关闭连接。
3. 滑动窗口机制 -- 如果每个包都进行ACK确认，性能较差，所以可以持续发送，统计进行ACK确认。
    > 窗口大小指的是无需等待确认应答而可以继续发送的数据的最大值，这个最大值由接收方的接收缓冲区大小决定。    
    > 在TCP建立连接时，就已经协商好窗口大小。   
4. 快重传 -- 当服务端回复的ACK丢失时，并不重要，因为后续的ACK，会表面当前包已收到；如果连续收到3个相同ACK，则表明当前包丢失，需要重传。
5. 流量控制 -- TCP支持根据接收端的处理能力，来决定发送端的发送速度，这个机制就叫做流量控制。  
    > 接收端将自己可以接收的缓冲区大小放入TCP首部中的“窗口大小”字段，通过ACK端通知发送端。 
6. 拥塞控制
    * 慢启动 --  到达拥塞窗口前，指数增长 -- 到达拥塞窗口后，线性增长
    * 发生拥塞 -- 拥塞窗口减半，重新开始慢启动（从1开始）
7. 延时应答 -- 服务端会略微延迟回复ACK包，让滑动窗口大一些（因为服务器可能很快消耗缓冲区中的数据）。

##### TCP粘包/拆包
tcp为提高性能，发送端会将需要发送的数据发送到缓冲区，等待缓冲区满了之后，再将缓冲中的数据发送到接收方。同理，接收方也有缓冲区这样的机制，来接收数据。  
**粘包/拆包原因:**  
1. 应用程序写入的数据大于套接字缓冲区大小，这将会发生拆包。
2. 应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包。
3. 接收方法不及时读取套接字缓冲区数据，这将发生粘包。    

**解决办法：** -- 应用层
1. 数据段定长处理，位数不足的空位补齐。
2. 消息头+消息体，消息头中一般会包含消息体的长度，消息类型等信息，消息体为实际数据体。  
3. 特殊字符（如：回车符）作为消息数据的结尾，以实现消息数据的分段。 

<br/>

### 其他问题  
##### 网关的作用：
1. 转发
2. 心跳；网关定时发送心跳给连接在这个网关上的所有客户端，保证客户端与网关的连接，如果某个客户端掉线了，那么网关就通知各个服务器去做玩家的下线处理
3. 负载均衡
4. 维持客户端的登录态








